<?php

/**
 * @file
 * Headless allows you to use Backdrop CMS as an API.
 */

/**
 * Implements hook_menu().
 */
function headless_menu() {
  $items = array();
  // Return JSON for individual nodes.
  $items['api/node/%/%'] = array(
    'page callback' => 'headless_type',
    'access callback' => TRUE,
    'page arguments' => array(2, 3),
  );
  $items['api/v2/node/%/%'] = array(
    'page callback' => 'headless_type_v2',
    'access callback' => TRUE,
    'page arguments' => array(3, 4),
  );
  // The following is for the node type where an id is not specified - to return all of the specified or a paginated subset.
  $items['api/node/%'] = array(
    'page callback' => 'headless_types',
    'access callback' => TRUE,
    'page arguments' => array(2),
  );
  // Return JSON for individual terms.
  $items['api/%/term/%'] = array(
    'page callback' => 'headless_term_item',
    'access callback' => TRUE,
    'page arguments' => array(1, 3),
  );
  $items['api/views/%'] = array(
    'page callback' => 'headless_views',
    'access callback' => TRUE,
    'page arguments' => array(2),
  );
  $items['api/v2/views/%/%'] = array(
    'page callback' => 'headless_views_v2',
    'access callback' => TRUE,
    'page arguments' => array(3, 4),
  );
  if (module_exists('paragraphs')) {
    // Return json for individual paragraphs.
    $items['api/paragraphs/%/%'] = array(
      'page callback' => 'headless_paragraphs_item',
      'access callback' => TRUE,
      'page arguments' => array(2, 3),
    );
    $items['api/v2/paragraphs/%/%'] = array(
      'page callback' => 'headless_paragraphs_item_v2',
      'access callback' => TRUE,
      'page arguments' => array(3, 4),
    );
    $items['api/v3/paragraphs/%'] = array(
      'page callback' => 'headless_paragraphs_item_v3',
      'access callback' => TRUE,
      'page arguments' => array(3),
    );
  }
  $items['api/blocks/%'] = array(
    'page callback' => 'headless_blocks',
    'access callback' => TRUE,
    'page arguments' => array(2),
  );
  $items['admin/config/services/headless'] = array(
    'title' => 'Headless settings',
    'description' => 'Configure the entity types you wish to expose as json endpoints.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('headless_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/headless.admin.inc',
  );

  // Router: allow API queries via string paths.
  $items['api/router/%'] = array(
    'title' => 'Headless router',
    'description' => 'Allow queries via string like /api/my-node-title',
    'page callback' => 'headless_router',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'file' => 'includes/headless.router.inc',
  );

  return $items;
}

/**
 * Page callback for node types.
 *
 * This is kept to make it backwards compatible
 */
function headless_type($type, $nid) {
  $config = config_get('headless.settings', 'node');
  // Check if the JSON output is enabled for the selected type.
  if ($config[$type] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
  // Load the requested node and check to see if types match or not.
  $requested_node = node_load($nid);
  if ($requested_node->type == $type) {
    backdrop_json_output($requested_node);
    backdrop_exit();
  }
  else {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
}

/**
 * Page callback for node types v2.
 */
function headless_type_v2($type, $nid) {
  // Check if the JSON output is enabled for the selected type.
  $config = config_get('headless.settings', 'node');
  if ($config[$type] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
  // Load the requested node and check to see if types match or not.
  $requested_node = node_load($nid);
  if ($requested_node->type == $type) {
    $my_json = node_view($requested_node);
    backdrop_json_output($my_json);
    backdrop_exit();
  }
  else {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
}

/**
 * Page callback for nodes type when no {$id} is specified - with or without pagination.
 *
 * Queries are in the format of :
 * GET /api/node/{type}?page[number]=X&page[size]=Y
 *                  OR
 * GET /api/node/{type}
 *
 * @param string $type
 *   A string indicating the node type to query
 */
function headless_types($type) {
  $opt_page_number = NULL;
  $opt_page_size   = NULL;

  $config = config_get('headless.settings', 'node');
  // Check if output is enabled... if not return an error.
  if ($config[$type] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }

  // Get any optional arguments provided -- specifically we're interested in page[number]=value and page[size]=value.
  $opt_query_args = backdrop_get_query_parameters();
  // Is this proper php etiquette? Can it be safely removed?
  // furthermore, we ASSUME that both the page number AND page size will always be specified as a pair.
  if (count($opt_query_args) > 0) {
    $opt_page_number = $opt_query_args['page']["number"];
    $opt_page_size   = $opt_query_args['page']['size'];
  }

  // Validate all the optional argument possibilities. If anything looks wonky, return the specified error.
  $ret_json_err = _validate_optional_values($opt_page_size, $opt_page_number);
  if (is_null($ret_json_err) == FALSE) {
    backdrop_json_output($ret_json_err);
    backdrop_exit();
  }

  // Get the items to be returned in this JSON query..
  $nodes_to_return = _nodes_get_node_result($type, $opt_page_size, $opt_page_number);
  backdrop_json_output($nodes_to_return);
  backdrop_exit();
}

/**
 * Page callback for terms.
 */
function headless_term_item($vocab, $tid) {
  $config = config_get('headless.settings', 'vocabularies');
  if ($config[$vocab] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
  $my_json = taxonomy_term_load($tid);
  backdrop_json_output($my_json);
  backdrop_exit();
}

/**
 * Page callback for views.
 *
 * This is kept to make it backwards compatible
 */
function headless_views($view) {
  $config = config_get('headless.settings', 'views');
  if ($config[$view] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
  $results = views_get_view_result($view);
  $count = count($results);
  $my_json = [
    'results' => $results,
    'count' => $count,
  ];
  backdrop_json_output($my_json);
  backdrop_exit();
}

/**
 * Page callback for views v2.
 */
function headless_views_v2($view, $display_id) {
  $args = func_get_args();
  $config = config_get('headless.settings', 'views');
  if ($config[$view] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
  $return = _views_get_view_result($view, $display_id, $args);

  $my_json = [
    'results' => $return['results'],
    'total_items' => $return['total_items'],
    'items_per_page' => $return['items_per_page'],
    'total_pages' =>
      (isset($return['items_per_page'])) ? ceil($return['total_items'] / $return['items_per_page']) : NULL,
    'current_page' => $return['current_page'],
  ];
  backdrop_json_output($my_json);
  json_last_error_msg();
  backdrop_exit();
}

/**
 * Page callback for paragraph types.
 */
function headless_paragraphs_item($type, $entity_id) {
  $config = config_get('headless.settings', 'paragraphs');
  if ($config[$type] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
  $result = paragraphs_item_load($entity_id);
  backdrop_json_output($result);
  backdrop_exit();
}

/**
 * Page callback for paragraph types v2.
 */
function headless_paragraphs_item_v2($type, $entity_id) {
  $config = config_get('headless.settings', 'paragraphs');
  if ($config[$type] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
  $result = paragraphs_item_load($entity_id)->view();
  backdrop_json_output($result);
  backdrop_exit();
}

/**
 * Page callback for paragraph types v3.
 */
function headless_paragraphs_item_v3($entity_id) {
  $config = config_get('headless.settings', 'paragraphs');
  $p = paragraphs_item_load($entity_id);
  if ($config[$p->bundle] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }
  $result = $p->view();
  backdrop_json_output($result);
  backdrop_exit();
}
/**
 * Page callback for blocks.
 *
 * This is kept to make it backwards compatible
 */
function headless_blocks($block) {
  $config = config_get('headless.settings', 'blocks');

  if ($config[$block] != 1) {
    $json_error = ['code' => 404];
    backdrop_json_output($json_error);
    backdrop_exit();
  }

  $result = config_get('block.custom.' . $block);
  backdrop_json_output($result);
  backdrop_exit();
}

/**
 * Helper function.
 *
 * We mimic the core function to add some extra pager data to the
 * returned value.
 */
function _views_get_view_result($name, $display_id = NULL, $args = NULL) {
  array_shift($args);
  if (count($args)) {
    array_shift($args);
  }

  $view = views_get_view($name);
  $return = array();
  if (is_object($view)) {
    if (is_array($args)) {
      $view->set_arguments($args);
    }
    if (is_string($display_id)) {
      $view->set_display($display_id);
    }
    else {
      $view->init_display();
    }
    $view->pre_execute();
    $view->execute();

    $total_items = $view->query->pager->total_items;
    $items_per_page = $view->query->pager->options['items_per_page'];
    $current_page = $view->query->pager->current_page;

    $return['total_items'] = $total_items;
    $return['items_per_page'] = $items_per_page;
    $return['current_page'] = $current_page;
    $return['results'] = $view->result;
    return $return;
  }
  else {
    return array();
  }
}

/**
 * Validate the various possible optional values if they're specified.
 *
 * Return the first issue found if any.
 *
 * @param int $opt_page_size
 *   Specifies the optional page size for paginated queries or NULL if not desired
 *
 * @param int $opt_page_number
 *   Specifies the optional page number for paginated queries or NULL if not desired
 *
 * @return array
 *   An associative array identifying the JSON error to be returned
 *   OR NULL if no error found
 */
function _validate_optional_values($opt_page_size, $opt_page_number) {
  $ret_json_err = NULL;

  // First check to see if neither were specified -- if so we can just return..
  if ((is_null($opt_page_number) == TRUE) && (is_null($opt_page_size) == TRUE)) {
    return $ret_json_err;
  }

  // Check the optional arguments to ensure both are specified and not just one.
  if ((is_null($opt_page_number) == TRUE) && (is_null($opt_page_size) == FALSE)) {
    // If either-or then this is considered an error and we can return one.
    $ret_json_err = ['code' => 422,
      'source' => "page[size] specified but NOT page[number]",
      'title' => "Invalid optional argument",
      'detail' => "Both Page size and Page number MUST be specified as a pair"];
    return $ret_json_err;
  }

  if ((is_null($opt_page_number) == FALSE) && (is_null($opt_page_size) == TRUE)) {
    // If either-or then this is considered an error and we can return one.
    $ret_json_err = ['code' => 422,
      'source' => "page[number] specified but NOT page[size]",
      'title' => "Invalid optional argument",
      'detail' => "Both Page size and Page number MUST be specified as a pair"];
    return $ret_json_err;
  }

  // Check to see if either page number or page size = 0.  If so return an error..
  if ($opt_page_size == 0) {
    $ret_json_err = ['code' => 422,
      'source' => "page[size] specified as zero",
      'title' => "Invalid optional argument",
      'detail' => "Page size must be >0"];
    return $ret_json_err;
  }

  if ($opt_page_number == 0) {
    $ret_json_err = ['code' => 422,
      'source' => "page[number] specified as zero",
      'title' => "Invalid optional argument",
      'detail' => "Page number must be >0"];
    return $ret_json_err;
  }
  return $ret_json_err;
}

/**
 * Issue a query to the database to get the desired nodes for the specified type.
 *
 * Return the nodes matching what the user wants - pagination will be done if specified by the arguments below.
 *
 * @param string $type
 *   A string specifying the node type to search for.
 *
 * @param int $page_size
 *   An integer indicating the page size to use for queries using pagination. If pagination is not desired, use NULL.
 *
 * @param int $page_number
 *   An integer indicating the page number to use for queries using pagination. If pagination is not desired, use NULL.
 *
 * @return bool|EntityInterface|null
 *   An array of nodes matching the type specified and according to the pagination values (if provided).
 */
function _nodes_get_node_result($type, $page_size, $page_number) {
  // Load the requested node and check to see if types match or not.
  $query = new EntityFieldQuery();
  $nodes = NULL;

  // If pagination is not specified, just return the entire set of nodes..
  if ((is_null($page_number) == TRUE) && (is_null($page_size) == TRUE)) {
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', $type)
      // Get only published items by checking the status.
      ->propertyCondition('status', 1);
  }
  else {
    // If we get here we're doing a paginated query.. Figure out what range we need to use.
    $start_index = ($page_size * $page_number) - $page_size;
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', $type)
      // Get only published items by checking the status.
      ->propertyCondition('status', 1)
      ->range($start_index, $page_size);
  }

  // Do the query..
  $result = $query->execute();
  if (isset($result['node'])) {
    $nodes = entity_load('node', array_keys($result['node']));
  }
  return ($nodes);
}
